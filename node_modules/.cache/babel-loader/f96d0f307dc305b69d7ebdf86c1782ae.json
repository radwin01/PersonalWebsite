{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport Box from 'ui-box';\nimport SegmentedControlAppearances from './styles/SegmentedControlAppearances';\nimport SegmentedControlRadio from './SegmentedControlRadio';\nvar keysSegmentedControlAppearances = Object.keys(SegmentedControlAppearances);\nvar radioCount = 1; // Used for generating unique input names\n\nvar SegmentedControl = function (_PureComponent) {\n  _inherits(SegmentedControl, _PureComponent);\n\n  function SegmentedControl(props, context) {\n    _classCallCheck(this, SegmentedControl);\n\n    var _this = _possibleConstructorReturn(this, (SegmentedControl.__proto__ || Object.getPrototypeOf(SegmentedControl)).call(this, props, context));\n\n    _this.handleChange = function (value) {\n      // Save a render cycle when it's a controlled input\n      if (!_this.props.value) {\n        _this.setState({\n          value: value\n        });\n      }\n\n      if (_this.props.onChange) {\n        _this.props.onChange(value);\n      }\n    };\n\n    _this.state = {\n      value: props.defaultValue || props.options[0].value\n    };\n    _this.name = 'SegmentedControl-' + radioCount;\n    radioCount += 1;\n    return _this;\n  }\n\n  _createClass(SegmentedControl, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          name = _props.name,\n          height = _props.height,\n          options = _props.options,\n          onChange = _props.onChange,\n          appearance = _props.appearance,\n          defaultValue = _props.defaultValue,\n          props = _objectWithoutProperties(_props, ['name', 'height', 'options', 'onChange', 'appearance', 'defaultValue']); // Allows it to behave like a controlled input\n\n\n      var value = this.props.value || this.state.value;\n      return React.createElement(Box, _extends({\n        display: 'flex',\n        marginRight: -1,\n        height: height\n      }, props), options.map(function (option, index) {\n        return React.createElement(SegmentedControlRadio, {\n          key: option.value,\n          name: name,\n          label: option.label,\n          value: option.value,\n          height: height,\n          checked: value === option.value,\n          onChange: _this2.handleChange,\n          appearance: appearance,\n          isFirstItem: index === 0,\n          isLastItem: index === options.length - 1\n        });\n      }));\n    }\n  }]);\n\n  return SegmentedControl;\n}(PureComponent);\n\nSegmentedControl.propTypes = _extends({}, Box.propTypes, {\n  appearance: PropTypes.oneOf(keysSegmentedControlAppearances),\n  options: PropTypes.arrayOf(PropTypes.shape({\n    label: PropTypes.node.isRequired,\n    value: PropTypes.string.isRequired\n  })).isRequired,\n  name: PropTypes.string,\n  value: PropTypes.string,\n  height: PropTypes.string,\n  onChange: PropTypes.func,\n  defaultValue: PropTypes.string\n});\nSegmentedControl.defaultProps = {\n  height: 32,\n  appearance: 'default'\n};\nexport default SegmentedControl;","map":{"version":3,"sources":["../../../src/segmented-control/src/SegmentedControl.js"],"names":["keysSegmentedControlAppearances","Object","radioCount","SegmentedControl","PureComponent","propTypes","Box","appearance","PropTypes","options","label","value","isRequired","name","string","height","onChange","func","defaultValue","defaultProps","props","option","index"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react'\nimport PropTypes from 'prop-types'\nimport Box from 'ui-box'\nimport SegmentedControlAppearances from './styles/SegmentedControlAppearances'\nimport SegmentedControlRadio from './SegmentedControlRadio'\n\nconst keysSegmentedControlAppearances = Object.keys(SegmentedControlAppearances)\nlet radioCount = 1 // Used for generating unique input names\n\nexport default class SegmentedControl extends PureComponent {\n  static propTypes = {\n    ...Box.propTypes,\n    appearance: PropTypes.oneOf(keysSegmentedControlAppearances),\n    options: PropTypes.arrayOf(\n      PropTypes.shape({\n        label: PropTypes.node.isRequired,\n        value: PropTypes.string.isRequired\n      })\n    ).isRequired,\n    name: PropTypes.string,\n    value: PropTypes.string,\n    height: PropTypes.string,\n    onChange: PropTypes.func,\n    defaultValue: PropTypes.string\n  }\n\n  static defaultProps = {\n    height: 32,\n    appearance: 'default'\n  }\n\n  constructor(props, context) {\n    super(props, context)\n\n    this.state = {\n      value: props.defaultValue || props.options[0].value\n    }\n\n    this.name = `SegmentedControl-${radioCount}`\n    radioCount += 1\n  }\n\n  handleChange = value => {\n    // Save a render cycle when it's a controlled input\n    if (!this.props.value) {\n      this.setState({ value })\n    }\n\n    if (this.props.onChange) {\n      this.props.onChange(value)\n    }\n  }\n\n  render() {\n    const {\n      name,\n      height,\n      options,\n      onChange,\n      appearance,\n      defaultValue,\n      ...props\n    } = this.props\n\n    // Allows it to behave like a controlled input\n    const value = this.props.value || this.state.value\n    return (\n      <Box display=\"flex\" marginRight={-1} height={height} {...props}>\n        {options.map((option, index) => (\n          <SegmentedControlRadio\n            key={option.value}\n            name={name}\n            label={option.label}\n            value={option.value}\n            height={height}\n            checked={value === option.value}\n            onChange={this.handleChange}\n            appearance={appearance}\n            isFirstItem={index === 0}\n            isLastItem={index === options.length - 1}\n          />\n        ))}\n      </Box>\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"module"}